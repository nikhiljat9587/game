<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake Game — Enhanced (Responsive)</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0;font-family:Inter,Segoe UI,system-ui,Arial;}
  html,body{
    width:100%;height:100%;overflow:hidden;touch-action:none;
    background:linear-gradient(135deg,#0b1020,#071126);color:#e8fff7;padding:12px;
  }
  .wrap{width:100%;max-width:720px;margin:0 auto}
  h1{font-size:1.6rem;text-align:center;margin-bottom:12px;color:transparent;
      background:linear-gradient(90deg,#00ff88,#00ccff);-webkit-background-clip:text;}
  .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:12px;flex-wrap:wrap}
  .scorebox{background:rgba(255,255,255,0.03);padding:10px;border-radius:10px;border:1px solid rgba(0,255,136,0.12);display:flex;gap:12px;align-items:center}
  .scorebox div{font-weight:700}
  .board-wrap{position:relative;background:#000;border-radius:12px;padding:10px;border:4px solid rgba(0,255,136,0.12);box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  canvas{display:block;width:100%;height:auto;max-height:78vh;background:linear-gradient(180deg,#03030a,#020207);border-radius:8px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px;justify-content:center}
  .btn{background:linear-gradient(90deg,#00ff88,#00ccff);color:#000;padding:8px 12px;border-radius:8px;border:none;font-weight:700;cursor:pointer}
  .small{padding:6px 8px;font-size:0.9rem}
  .control-btn{width:52px;height:52px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#bfffd8;font-size:1.2rem}
  .game-over{position:absolute;inset:0;background:rgba(0,0,0,0.7);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:5;backdrop-filter: blur(3px);display:none}
  .game-over h2{color:#ff6b88;margin-bottom:12px}
  .players{margin-top:8px;font-size:0.9rem;color:#bcd}
  .login{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#eaf;}
  .info{font-size:0.9rem;color:#9ecab0;margin-top:8px;text-align:center}

  /* FULL RESPONSIVE MODE */
  @media (max-width:480px){
    .wrap{padding:0;margin-top:4px}
    h1{font-size:1.3rem;margin:4px 0}
    .topbar{flex-direction:column;gap:6px}
    .login{flex-direction:column;width:100%}
    input[type=text]{width:100%}
    .board-wrap{padding:4px;border-width:2px}
    canvas{height:60vh;width:100%}
    .control-btn{width:46px;height:46px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Snake Game — Enhanced</h1>
    <div class="topbar">
      <div class="scorebox">
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="high">0</span></div>
        <div>Speed: <span id="spd">Normal</span></div>
      </div>

      <div class="login">
        <input id="name" type="text" placeholder="Your name (for online)" hidden />
        <input id="wsurl" type="text" placeholder="WebSocket URL (optional)" style="min-width:220px" hidden />
        <button id="connectBtn" class="btn small" hidden>Connect</button>
      </div>
    </div>

    <div class="board-wrap">
      <canvas id="game"></canvas>

      <div class="game-over" id="gameOver">
        <h2>Game Over</h2>
        <div id="finalScore" style="margin-bottom:10px;color:#cfe"></div>
        <button id="restart" class="btn">Play Again</button>
        <div class="players" id="playersList"></div>
      </div>
    </div>

    <div class="controls">
      <button class="control-btn" id="up">↑</button>
      <div style="display:flex;gap:8px">
        <button class="control-btn" id="left">←</button>
        <button class="control-btn" id="down">↓</button>
        <button class="control-btn" id="right">→</button>
      </div>

      <button id="mute" class="btn small">Mute Voice</button>
      <button id="speedDown" class="btn small">Slower</button>
      <button id="speedUp" class="btn small">Faster</button>
    </div>

    <div class="info">Swipe on phone or use arrow keys. Supports WebSocket presence.</div>
  </div>

<script>
/* ----------------------------
   CONFIG & STATE
   ---------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const spdEl = document.getElementById('spd');
const gameOverEl = document.getElementById('gameOver');
const restartBtn = document.getElementById('restart');
const finalScoreEl = document.getElementById('finalScore');
const playersList = document.getElementById('playersList');

let gridSize = 20;            // pixels per cell (updated by resize)
let cols = 20, rows = 20;
let speedMs = 140;           // ms per move (lower => faster)
let lastMove = 0;
let score = 0, high = localStorage.getItem('snakeHigh')||0;
highEl.textContent = high;

let snake = [];
let dir = {x:1,y:0};         // current direction
let nextDir = {x:1,y:0};     // buffered direction (prevent reverse)
let food = {x:0,y:0};
let length = 3;
let running = false;
let muted = false;

/* MULTIPLAYER (WebSocket presence)
   client sends simple JSON messages:
   {type:"join",name:"..."}
   {type:"eat",score:NUMBER}
   server expected to broadcast {type:"players", list:[{name,score?}]}
   This is optional — if wsUrl left empty, local play only.
*/
let ws = null;
const connectBtn = document.getElementById('connectBtn');
const nameInput = document.getElementById('name');
const wsInput = document.getElementById('wsurl');

/* ----------------------------
   RESIZE & GRID
   ---------------------------- */
function resizeCanvas(){
  const board = document.querySelector('.board-wrap');
  const size = Math.min(board.clientWidth - 20, 520); // responsive
  canvas.width = size;
  canvas.height = size;
  // recompute grid cells so snake fits nicely
  // prefer integer cells count between 12 and 28
  const best = Math.max(12, Math.min(28, Math.floor(size / 20)));
  cols = rows = best;
  gridSize = Math.floor(size / cols);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ----------------------------
   UTIL: speak & sounds
   ---------------------------- */
function speak(text){
  if(muted) return;
  if('speechSynthesis' in window){
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'en-US';
    u.pitch = 1;
    u.rate = 1;
    speechSynthesis.cancel(); // quick interrupt previous
    speechSynthesis.speak(u);
  }
}
// optional small beep using oscillator (no files)
function beep(duration=120, freq=600, vol=0.05){
  if(muted) return;
  try{
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(ac.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ac.close(); }, duration);
  }catch(e){
    // ignore
  }
}

/* ----------------------------
   GAME: init / place food / draw
   ---------------------------- */
function initGame(){
  snake = [];
  const startX = Math.floor(cols/2);
  const startY = Math.floor(rows/2);
  snake.push({x:startX, y:startY});
  dir = {x:1,y:0};
  nextDir = {x:1,y:0};
  length = 3;
  score = 0;
  scoreEl.textContent = score;
  gameOverEl.style.display = 'none';
  running = true;
  placeFood();
  lastMove = performance.now();
  requestAnimationFrame(loop);
}

function placeFood(){
  let tries=0;
  while(tries<1000){
    const fx = Math.floor(Math.random()*cols);
    const fy = Math.floor(Math.random()*rows);
    if(!snake.some(s=>s.x===fx && s.y===fy)){
      food = {x:fx,y:fy};
      return;
    }
    tries++;
  }
}

// draw grid, food, snake (head rotated)
function draw(){
  // background
  const w = canvas.width, h = canvas.height;
  const g = ctx.createLinearGradient(0,0,w,h);
  g.addColorStop(0,'#020214'); g.addColorStop(1,'#001017'); 
  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  // subtle grid
  ctx.strokeStyle = 'rgba(0,255,136,0.04)'; ctx.lineWidth = 1;
  for(let x=0;x<=cols;x++){
    ctx.beginPath(); ctx.moveTo(x*gridSize,0); ctx.lineTo(x*gridSize,h); ctx.stroke();
  }
  for(let y=0;y<=rows;y++){
    ctx.beginPath(); ctx.moveTo(0,y*gridSize); ctx.lineTo(w,y*gridSize); ctx.stroke();
  }

  // draw food (as small rat-like circle with tail)
  const fx = food.x*gridSize, fy = food.y*gridSize;
  ctx.save();
  ctx.translate(fx+gridSize/2, fy+gridSize/2);
  ctx.fillStyle = '#ff3366';
  ctx.beginPath(); ctx.arc(0,0,gridSize*0.38,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.arc(-gridSize*0.12,-gridSize*0.12,gridSize*0.12,0,Math.PI*2); ctx.fill();
  // tail
  ctx.strokeStyle='#ff3366'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(gridSize*0.28,0); ctx.lineTo(gridSize*0.5, -gridSize*0.18); ctx.stroke();
  ctx.restore();

  // draw body segments
  for(let i=0;i<snake.length-1;i++){
    const s = snake[i];
    const x = s.x*gridSize, y = s.y*gridSize;
    const grad = ctx.createLinearGradient(x,y,x+gridSize,y+gridSize);
    grad.addColorStop(0,'#00ff88'); grad.addColorStop(1,'#00ccff');
    ctx.fillStyle = grad;
    roundRect(ctx, x+2, y+2, gridSize-4, gridSize-4, 6, true, false);

    // shine
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(x+4, y+4, gridSize-8, Math.max(3, gridSize/8));
  }

  // draw head with rotation according to dir
  const head = snake[snake.length-1];
  const hx = head.x*gridSize, hy = head.y*gridSize;
  // compute angle from dir
  let angle = 0;
  if(dir.x === 1) angle = 0; // right
  if(dir.x === -1) angle = Math.PI; // left
  if(dir.y === 1) angle = Math.PI/2; // down
  if(dir.y === -1) angle = -Math.PI/2; // up

  ctx.save();
  ctx.translate(hx + gridSize/2, hy + gridSize/2);
  ctx.rotate(angle);
  // head body
  const headGrad = ctx.createLinearGradient(-gridSize/2,-gridSize/2,gridSize/2,gridSize/2);
  headGrad.addColorStop(0,'#00ff88'); headGrad.addColorStop(1,'#00ccff');
  ctx.fillStyle = headGrad;
  roundRect(ctx, -gridSize/2 + 2, -gridSize/2 + 2, gridSize-4, gridSize-4, 6, true, false);

  // eyes (on head, rotate with it)
  ctx.fillStyle = '#001';
  ctx.fillRect(gridSize*0.08 - 3, -gridSize*0.2, 4, 4);
  ctx.fillRect(-gridSize*0.08 - 1, -gridSize*0.2, 4, 4);

  // small mouth dot
  ctx.fillStyle = '#001';
  ctx.fillRect(0, gridSize*0.12, 4, 3);

  ctx.restore();
}

// helper: rounded rect
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if(typeof r==='undefined') r=4;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* ----------------------------
   UPDATE: move snake, check collisions
   ---------------------------- */
function update(){
  if(!running) return;

  // apply buffered direction but prevent reversing into self
  if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
    dir = {...nextDir};
  }

  // new head
  const last = snake[snake.length-1];
  const newHead = { x: last.x + dir.x, y: last.y + dir.y };

  // wall collision -> game over
  if(newHead.x < 0 || newHead.x >= cols || newHead.y < 0 || newHead.y >= rows){
    onGameOver();
    return;
  }

  // self collision
  for(let i=0;i<snake.length;i++){
    if(snake[i].x === newHead.x && snake[i].y === newHead.y){
      onGameOver();
      return;
    }
  }

  snake.push(newHead);
const foodVoice = new Audio("eat.mp3");   // jab snake food khaye
  // jab snake out ho jaye

  // food?
  if(newHead.x === food.x && newHead.y === food.y){
    length++;
    score += 10;
    scoreEl.textContent = score;
    // voice + beep
    foodVoice.currentTime = 0;
foodVoice.play();
    beep(100, 900, 0.06);
    // notify server if connected
    if(ws && ws.readyState===WebSocket.OPEN){
      ws.send(JSON.stringify({type:'eat',name:nameInput.value||'anon',score}));
    }
    placeFood();
    // speed up a bit
    speedMs = Math.max(50, speedMs - 4);
    updateSpeedLabel();
  } else {
    // trim tail
    while(snake.length > length) snake.shift();
  }
}

/* ----------------------------
   GAME LOOP (timed by speedMs)
   ---------------------------- */
function loop(ts){
  if(!running){ requestAnimationFrame(loop); return; }
  if(ts - lastMove >= speedMs){
    update();
    draw();
    lastMove = ts;
  }
  requestAnimationFrame(loop);
}

/* ----------------------------
   GAME OVER handling
   ---------------------------- */
const outVoice = new Audio("out.mp3");  
function onGameOver(){
    running = false;

    // ---- OUT VOICE ----
    outVoice.currentTime = 0;
    outVoice.play();
    beep(350, 220, 0.06);

    if(score > high){
        high = score;
        localStorage.setItem('snakeHigh', high);
        highEl.textContent = high;
    }

    finalScoreEl.textContent = `Score: ${score}`;
    gameOverEl.style.display = 'flex';

    if(ws && ws.readyState === WebSocket.OPEN){
        ws.send(JSON.stringify({
            type:'dead',
            name:nameInput.value||'anon',
            score
        }));
    }
}

/* ----------------------------
   INPUT: keyboard & buttons & swipe
   ---------------------------- */
document.addEventListener('keydown', e=>{
  if(!running) return;
  if(e.key==='ArrowUp'){ if(dir.y!==1) nextDir = {x:0,y:-1} }
  if(e.key==='ArrowDown'){ if(dir.y!==-1) nextDir = {x:0,y:1} }
  if(e.key==='ArrowLeft'){ if(dir.x!==1) nextDir = {x:-1,y:0} }
  if(e.key==='ArrowRight'){ if(dir.x!==-1) nextDir = {x:1,y:0} }
  // speed control
  if(e.key==='+'){ speedMs = Math.max(40, speedMs-10); updateSpeedLabel(); }
  if(e.key==='-'){ speedMs = Math.min(400, speedMs+10); updateSpeedLabel(); }
});

document.getElementById('up').addEventListener('click', ()=>{ if(dir.y!==1) nextDir={x:0,y:-1} });
document.getElementById('down').addEventListener('click', ()=>{ if(dir.y!==-1) nextDir={x:0,y:1} });
document.getElementById('left').addEventListener('click', ()=>{ if(dir.x!==1) nextDir={x:-1,y:0} });
document.getElementById('right').addEventListener('click', ()=>{ if(dir.x!==-1) nextDir={x:1,y:0} });

let tsX=0, tsY=0;
canvas.addEventListener('touchstart', e=>{
  tsX = e.touches[0].clientX; tsY = e.touches[0].clientY;
});
canvas.addEventListener('touchend', e=>{
  const ex = e.changedTouches[0].clientX, ey = e.changedTouches[0].clientY;
  const dx = ex - tsX, dy = ey - tsY;
  if(Math.abs(dx) > Math.abs(dy)){
    if(dx>20 && dir.x!==-1) nextDir={x:1,y:0};
    if(dx<-20 && dir.x!==1) nextDir={x:-1,y:0};
  } else {
    if(dy>20 && dir.y!==-1) nextDir={x:0,y:1};
    if(dy<-20 && dir.y!==1) nextDir={x:0,y:-1};
  }
});

/* ----------------------------
   UI Button events
   ---------------------------- */
document.getElementById('mute').addEventListener('click', ()=>{
  muted = !muted;
  document.getElementById('mute').textContent = muted ? 'Unmute Voice' : 'Mute Voice';
});

document.getElementById('speedUp').addEventListener('click', ()=>{
  speedMs = Math.max(40, speedMs-12); updateSpeedLabel();
});
document.getElementById('speedDown').addEventListener('click', ()=>{
  speedMs = Math.min(500, speedMs+12); updateSpeedLabel();
});

function updateSpeedLabel(){
  if(speedMs <= 70) spdEl.textContent = 'Fast';
  else if(speedMs <= 120) spdEl.textContent = 'Normal';
  else spdEl.textContent = 'Slow';
}
updateSpeedLabel();

restartBtn.addEventListener('click', ()=>{ initGame(); });

/* ----------------------------
   MULTIPLAYER: WebSocket connect & handling
   ---------------------------- */
connectBtn.addEventListener('click', ()=>{
  const url = wsInput.value.trim();
  const playerName = (nameInput.value || 'Player').trim();
  if(!url){
    alert('Enter WebSocket URL to connect for multiplayer (or leave blank for local play).');
    return;
  }
  if(ws && ws.readyState===WebSocket.OPEN){
    ws.close();
  }
  try{
    ws = new WebSocket(url);
  }catch(e){
    alert('Invalid WebSocket URL or unsupported in this browser.');
    return;
  }

  ws.addEventListener('open', ()=>{
    connectBtn.textContent = 'Connected';
    connectBtn.disabled = true;
    // join
    ws.send(JSON.stringify({type:'join',name:playerName}));
    // send initial score/state periodically
    setInterval(()=>{ if(ws && ws.readyState===WebSocket.OPEN) ws.send(JSON.stringify({type:'alive',name:playerName,score})); }, 5000);
  });

  ws.addEventListener('message', ev=>{
    try{
      const data = JSON.parse(ev.data);
      if(data.type === 'players' && Array.isArray(data.list)){
        // update UI list
        playersList.innerHTML = '<strong>Players online:</strong><br>' + data.list.map(p=>`${escapeHtml(p.name)}${p.score?(' — '+p.score):''}`).join('<br>');
      } else if(data.type === 'chat'){
        // optional future
      }
    }catch(e){}
  });

  ws.addEventListener('close', ()=>{
    connectBtn.textContent = 'Connect';
    connectBtn.disabled = false;
    playersList.textContent = 'Disconnected from server';
  });

  ws.addEventListener('error', ()=>{
    playersList.textContent = 'Connection error';
  });
});

/* ----------------------------
   ESCAPE HTML helper
   ---------------------------- */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ----------------------------
   INIT
   ---------------------------- */
initGame();
draw();

/* ----------------------------
   OPTIONAL: allow pausing on visibility change
   ---------------------------- */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){ /* pause movement but keep game visible */ }
});

</script>
</body>
</html>
